'use strict';
const os = require('os');
const fs = require('fs');
const assert = require('assert');
const _ = require('underscore');
require('../common/MoreUnderscore');

exports.FileGen = FileGen;
exports.escapeCString = escapeCString;
exports.escapeCJson = escapeCJson;
exports.mkCodeGen = mkCodeGen;

function escapeCString(s) {
  return s.replace(/[\000-\037\\"\'|]/g, "\\$&");
}

function escapeCJson(o) {
  let oStr = JSON.stringify(o);
  let oStrLen = oStr.length;
  let cStrings = ['""'];
  let chunk = 80;
  for (let i=0; i<oStrLen; i+= chunk) {
    cStrings.push('"' + escapeCString(oStr.substr(i, chunk)) + '"');
  }
  return cStrings.join('\n    ');
}

function mkCodeGen(filename, subs) {
  let contents = [];
  let subsPattern = new RegExp('(' + _.map(_.keys(subs), _.requote).join('|') + ')', 'g');

  function line(code) {
    if (_.isFunction(code)) {
      return code(line);
    }
    if (/(WARNING|ERROR)/.test(code)) {
      console.log(code);
    }
    _.each(code.trim().split('\n'), function(code) {
      code = code.replace(subsPattern, function(m) {
        if (m in subs) {
          return subs[m];
        } else {
          return m;
        }
      });

      contents.push(code.trim() + '\n');
    });
  }

  function expandContents(dst) {
    _.each(contents, function(c) {
      if (c.expandContents) {
        c.expandContents(dst);
      } else {
        dst.push(c);
      }
    });
  }

  function end() {
    let expContents = [];
    expandContents(expContents);

    if (!filename || /\.(c|cc|cpp|h|js)$/.exec(filename)) {
      cIndent(expContents);
    }
    if (filename && /\.h$/.exec(filename)) {
      hProtect(expContents);
    }

    let expContentsStr = expContents.join('');
    if (filename && fs.existsSync(filename)) {
      let text1 = fs.readFileSync(filename, 'utf8');
      if (withoutGeneratedLine(text1) === expContentsStr) {
        return;
      }
    }

    let fullContentsStr;
    if (!filename || /\.(gypi|json)$/.exec(filename)) {
      fullContentsStr = expContentsStr;
    } else {
      fullContentsStr = `/* Generated by ${process.argv.join(' ')} at ${(new Date().toUTCString())} */\n` + expContentsStr;
    }

    if (filename) {
      fs.writeFileSync(filename, fullContentsStr, 'utf8');
      if (1) console.log(`Wrote ${filename}`);
    } else {
      console.log(fullContentsStr);
    }
  }

  function hProtect(expContents) {
    let hpsym = `INCLUDE_${filename.replace(/[^a-zA-Z0-9]+/g, '_')}`;
    expContents.unshift(`#define ${hpsym}\n`);
    expContents.unshift(`#ifndef ${hpsym}\n`);
    expContents.push('#endif\n');
  }

  function cIndent(expContents) {
    let braceLevel = 0;
    let parenLevel = 0;
    let spaces = '                                                                                ';
    for (let ci=0; ci < expContents.length; ci++) {
      let l = expContents[ci];

      let ll = l.length;
      if (!(ll === 0 || l.charCodeAt(0) === 35)) {
        let minBraceLevel = braceLevel;
        let origParenLevel = parenLevel;
        let inDoubleQuote = false;
        let inSingleQuote = false;
        let inSingleLineComment = false;
        let escaped;
        let lastc = 0;
        for (let i = 0; i < ll; i++) {
          let c = l.charCodeAt(i);
          if (c === 92) {
            escaped = true;
            continue; // eslint-disable-line no-continue
          }
          if (c === 34 && !escaped) inDoubleQuote = !inDoubleQuote;
          if (c === 39 && !escaped) inSingleQuote = !inSingleQuote;
          if (!inDoubleQuote && !inSingleQuote && !inSingleLineComment) {
            if (c === 47 && lastc === 47) inSingleLineComment = true;
            if (c === 123) braceLevel++;
            if (c === 125) {
              braceLevel--;
              minBraceLevel = braceLevel;
            }
            if (c === 40) parenLevel++;
            if (c === 41) parenLevel--;
          }
          escaped = false;
          lastc = c;
        }
        let indentLevel = minBraceLevel * 2 + origParenLevel * 4;
        if (l === '}\n' && indentLevel === 0) {
          l = l + '\n';
        }
        expContents[ci] = spaces.substr(0, indentLevel) + l;
      }
    }
  }

  function child(moreSubs) {
    let childSubs;
    if (moreSubs) {
      childSubs = _.extend(_.clone(subs), moreSubs);
    } else {
      childSubs = subs;
    }
    let ret = mkCodeGen(filename, childSubs);
    contents.push(ret);
    return ret;
  }

  line.expandContents = expandContents;
  line.end = end;
  line.child = child;

  return line;
}


function withoutGeneratedLine(t) {
  return t.replace(/\/\* Generated by .* \*\/\n/g, '');
}


// ----------------------------------------------------------------------

function FileGen(prefix) {
  this.prefix = prefix;
  this.files = {};
}

FileGen.prototype.getFile = function(name) {
  let fn = this.prefix ? this.prefix + name : null;

  if (!(fn in this.files)) {
    this.files[fn] = mkCodeGen(fn, {FILENAME: name});
  }
  return this.files[fn];
};

FileGen.prototype.end = function() {
  _.each(this.files, function(cg) {
    cg.end();
  });
};
